<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Telegraphic gene expression ¬∑ ùïπùñöùñí‚ÑÇùïÑùîº</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ùïπùñöùñí‚ÑÇùïÑùîº</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Telegraphic gene expression</a><ul class="internal"><li><a class="tocitem" href="#Two-ways-to-input-a-stochastic-reaction-network-model"><span>Two ways to input a stochastic reaction network model</span></a></li><li><a class="tocitem" href="#Which-method-is-faster?"><span>Which method is faster?</span></a></li><li><a class="tocitem" href="#Remarks"><span>Remarks</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../hog1p/">MAPK-activated transcription in yeast</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../../api/models/">CME models</a></li><li><a class="tocitem" href="../../api/propensities/">Propensity functions</a></li><li><a class="tocitem" href="../../api/propensity_gradients/">Gradients of propensity functions</a></li><li><a class="tocitem" href="../../api/space/">Managing state space</a></li><li><a class="tocitem" href="../../api/vectors/">Representing the CME solution</a></li><li><a class="tocitem" href="../../api/cmesolve/">Transient solution of the CME</a></li><li><a class="tocitem" href="../../api/cmesenssolve/">Forward sensitivity analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Telegraphic gene expression</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Telegraphic gene expression</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/voduchuy/NumCME.jl/blob/main/docs/src/examples/telegraph.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Telegraphic-gene-expression"><a class="docs-heading-anchor" href="#Telegraphic-gene-expression">Telegraphic gene expression</a><a id="Telegraphic-gene-expression-1"></a><a class="docs-heading-anchor-permalink" href="#Telegraphic-gene-expression" title="Permalink"></a></h1><p>In this example, we will compute the time-varying solutions of the Chemical Master Equation (CME) describing the telegraph gene expression network (see the picture below), starting from an initial condition where the gene is inactive and there are no gene product.</p><p><img src="../assets/bursting_schematic.png" alt/></p><p>First let&#39;s make sure we can import the necessary Julia packages.</p><pre><code class="language-julia hljs">using NumCME
using Catalyst 
using Sundials: CVODE_BDF
using StaticArrays: @MVector</code></pre><h2 id="Two-ways-to-input-a-stochastic-reaction-network-model"><a class="docs-heading-anchor" href="#Two-ways-to-input-a-stochastic-reaction-network-model">Two ways to input a stochastic reaction network model</a><a id="Two-ways-to-input-a-stochastic-reaction-network-model-1"></a><a class="docs-heading-anchor-permalink" href="#Two-ways-to-input-a-stochastic-reaction-network-model" title="Permalink"></a></h2><p><code>NumCME</code> supports inputing the stochastic reaction network model using Julia&#39;s standard library. If you decide to go this route, you need to first define the stoichiometry matrix, then the propensity functions, the parameter vector, and call <a href="../../api/models/#NumCME.CmeModel"><code>CmeModel</code></a> constructor to put these elements together into a single model object.</p><pre><code class="language-julia hljs"># Bursting gene model definition using basic Julia
ùïä = [[-1, 1, 0] [1, -1, 0] [0, 0, 1] [0, 0, -1]]

a1 = propensity() do x, p
    p[1] * x[1]
end
a2 = propensity() do x, p
    p[2] * x[2]
end
a3 = propensity() do x, p
    p[3] * x[2]
end
a4 = propensity() do x, p
    p[4] * x[3]
end

kon = 0.05
koff = 0.1
kr = 5.0
Œ≥ = 0.5
Œ∏ = [kon, koff, kr, Œ≥]

model = CmeModel(ùïä, [a1, a2, a3, a4], Œ∏)</code></pre><p>On the other hand, you can also define a model using Catalyst&#39;s <a href="https://catalyst.sciml.ai/dev/tutorials/dsl/">DSL</a>. The following code snippet defines a <code>Catalyst.ReactionSystem</code> object that represents the reactions and propensity functions of the telegraph model.</p><pre><code class="language-julia hljs"># Bursting model definition using Catalyst 
@parameters k‚ÇÄ‚ÇÅ k‚ÇÅ‚ÇÄ Œª Œ≥
bursting_rn = @reaction_network begin 
    kon, Goff --&gt; Gon
    koff, Gon --&gt; Goff 
    kr, Gon --&gt; Gon + mRNA 
    Œ≥, mRNA --&gt; ‚àÖ
end k‚ÇÄ‚ÇÅ k‚ÇÅ‚ÇÄ Œª Œ≥</code></pre><p>You can then convert it into <code>NumCME.CmeModel</code> object like so:</p><pre><code class="language-julia hljs">parameter_values = [koff =&gt; 0.05, kon =&gt; 0.1, kr =&gt; 5.0, Œ≥ =&gt; 0.5]
model_from_catalyst = CmeModel(bursting_rn, parameter_values)</code></pre><p>Let&#39;s solve the CME using both model objects.</p><pre><code class="language-julia hljs">x‚ÇÄ = [1, 0, 0]
p0 = FspVectorSparse([@MVector x‚ÇÄ], [1.0]) # Specify initial condition
tspan = (0.0, 300.0)
fspalgorithm = AdaptiveFspSparse(
    ode_method=CVODE_BDF(linear_solver=:GMRES),
    space_adapter=RStepAdapter(5, 10, true)
)
fspsol1 = solve(model, p0, tspan, fspalgorithm)
fspsol2 = solve(model_from_catalyst, p0, tspan, fspalgorithm)</code></pre><p>Do these two numerical solutions agree?</p><pre><code class="language-julia hljs"># Check that the two ways to code the model lead to the same numerical outputs 
@assert length(fspsol1) == length(fspsol2)
for i ‚àà 1:length(fspsol1)
    @assert get_states(fspsol1[i].p) == get_states(fspsol2[i].p)
    @assert get_values(fspsol1[i].p) == get_values(fspsol2[i].p)
end</code></pre><h2 id="Which-method-is-faster?"><a class="docs-heading-anchor" href="#Which-method-is-faster?">Which method is faster?</a><a id="Which-method-is-faster?-1"></a><a class="docs-heading-anchor-permalink" href="#Which-method-is-faster?" title="Permalink"></a></h2><p>We have verified that the two ways to specify the telegraph model lead to the same numerical output. However, does the use of DSL degrade performance? The answer is a resounding NO. Here are the benchmarking results on an Apple M1 13inch Macbook.</p><pre><code class="language-julia hljs">julia&gt; using BenchmarkTools: @btime
julia&gt; @btime solve(model, p0, tspan, fspalgorithm);
5.454 ms (122573 allocations: 4.50 MiB)</code></pre><pre><code class="language-julia hljs">julia&gt; @btime solve(model_from_catalyst, p0, tspan, fspalgorithm);
5.418 ms (122573 allocations: 4.50 MiB)</code></pre><h2 id="Remarks"><a class="docs-heading-anchor" href="#Remarks">Remarks</a><a id="Remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Remarks" title="Permalink"></a></h2><ul><li>Specifying three species does <em>not</em> increase the number of states included in the FSP compared to formulating it as a two-species system (with gene ‚àà {ON, OFF} and RNA ‚àà {0,1,2,...} ). This is because only states that satisfy <code>Goff + Gon == 1</code> are reachable from the initial condition and <code>NumCME</code>&#39;s state space management, which is based on a reachability analysis of the CME state space, respects this constraint automatically. This is a feature of the &quot;N-step reachability&quot; state space exploration shceme introduced in the very first FSP paper by Munsky and Khammash <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</li><li>Thus, the estimate that the number of states increases as <span>$O(n^d)$</span>, while a useful heuristics, can be pessimistic for reaction networks with mass conservation.</li></ul><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>B. Munsky and M. Khammash, ‚ÄúThe finite state projection algorithm for the solution of the chemical master equation,‚Äù J. Chem. Phys., vol. 124, no. 4, p. 044104, Jan. 2006, doi: 10.1063/1.2145882.‚óä</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">¬´ Home</a><a class="docs-footer-nextpage" href="../hog1p/">MAPK-activated transcription in yeast ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 22 October 2022 15:16">Saturday 22 October 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
